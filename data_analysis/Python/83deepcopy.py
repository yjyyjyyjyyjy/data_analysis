if __name__ == "__main__":
    l1 = [3, [55, 44], (7, 8, 9)]
    # 浅拷贝（即复制了最外层容器，副本中的元素是源容器中元素的引用）。
    # 如果所有元素都是不可变的，那么这 样没有问题，还能节省内存。
    # 但是，如果有可变的元素，可能就会导致 意想不到的问题
    # 引用：对引用求地址，就是对目标变量求地址。 & ra与 & a相等。即常说引用名是目标变量名的一个别名。
    # 。。。。深复制（即副本不共享内部对象的引用）
    l2 = list(l1)
    print(l2 == l1)
    # 对象不同
    print(l2 is l1)

    # l2 没有此元素的引用
    l1.append(100)
    # l2 有此元素的引用（list 别名）
    l1[1].remove(55)

    print('l1:', l1)
    print('l2:', l2)
    # 可变元素
    # l2[1] 引用的列表，+= 运算符就地修改列 表。这次修改在 l1[1] 中也有体现，因为它是 l2[1] 的别名
    l2[1] += [33, 22]
    # 不可变元素
    # += 运算符创建一个新元组，然后重新绑定给变量l2[2]。
    # 这等同于 l2[2] = l2[2] + (10, 11)。现在，l1和l2中最后位置上的元组不是同一个对象
    l2[2] += (10, 11)
    print('l1:', l1)
    print('l2:', l2)
